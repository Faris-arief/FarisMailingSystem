/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('untitled:server');
var http = require('http');
const { Server } = require('socket.io'); 

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '4000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: 'http://localhost:3000',
    methods: ['GET', 'POST'],
  },
});

const CHAT_BOT = 'NFA Bot'; // Add this

let allUsers = []; // All users in current chat room
let roomMappedMessages = {};
io.on('connection', (socket) => {
  console.log(`Connection created ${socket.id}`);

  socket.on('join_room', (data) => {
    const { username,name, room } = data; // Data sent from client when join_room event emitted
    socket.join(room); // Join the user to a socket room
    allUsers.push({ id: socket.id, username, room });
 
    let createdTime = Date.now();

    roomMappedMessages[room] = []

    const enterMessage = {
      message: `${name} has joined the chat room`,
      username: CHAT_BOT,
      name: CHAT_BOT,
      createdTime,
    }
    const introductoryMessage = 
    {
      message: `Welcome ${name},\n if you would like to leave the chat just type 'leave' or 'exit'`,
      name: CHAT_BOT,
      username: CHAT_BOT,
      createdTime,
    };
    
    console.log("User entered with socket", socket.id);
    console.log("User entered with email", username);
    console.log(`User ${name} entered room ${room}`);
    console.log(`Bot will start conversing`, introductoryMessage   )
    socket.to(room).emit('receive_message', enterMessage);
    io.in(room).emit('receive_message', introductoryMessage);

    roomMappedMessages[room].push(enterMessage, introductoryMessage);
    
  });

  // We can write our socket event listeners in here...
  socket.on('send_message', (data) => {
    const { message, username,name, room, createdTime } = data;
    if(roomMappedMessages[room] == null)
      roomMappedMessages[room] = []


    io.in(room).emit('receive_message', data); // Send to all users in room, including sender
    console.log(`User ${username} spoke in room ${room}: ${message}`);
    roomMappedMessages[room].push(
      {
      message: message,
      username: username,
      name: name,
      createdTime,
      });

    const messageConfirmation = message.toLowerCase().trim()
    if(messageConfirmation == "leave" || messageConfirmation == "exit"){
      const leaveMessage = {
        message: `${username} has left the chat`,
        username: username,
        name: name,
        createdTime,
      }
      roomMappedMessages[room].push(
        leaveMessage
      );

      console.log(`${username} has left the chat`,)
      io.to(socket.id).emit('leave', 'Please leave the chat!');

      
      socket.leave(room);
      allUsers =  allUsers.filter((user) => user.id != socket.id);
      //socket.to(room).emit('chatroom_users', allUsers);
      return
    }

  });

  socket.on('leave_room', (data) => {
    const { room, username,name, createdTime } = data;
    socket.leave(room);
    // Remove user from memory
    allUsers =  allUsers.filter((user) => user.id != socket.id);
    //socket.to(room).emit('chatroom_users', allUsers);
    roomMappedMessages[room].push(
      {
        message: `${username} has left the chat`,
        username: username,
        name: name,
        createdTime,
        });
      });
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
